# Educational Problems

A collection of competitive programming problems Iâ€™ve solved, along with any new takeaways or lessons learned, and reasons I might want to revisit each problem later.

## Problem Collection

| # | Problem | Tag/Category | Difficulty | Takeaway | Revisit Note / Error Log | Code Link |
|---|-------------|--------------|------------|----------|--------------------------|-----------|
| 1 | [Link](https://codeforces.com/contest/2102/problem/D) | Data Structure | Div2D |  | <details><summary>View</summary>Parity dependency with inversion count</details> | [Solution](./codes/solution1.cpp) |
| 2 | [Link](https://atcoder.jp/contests/arc087/tasks/arc087_b) | Dynamic Programming | Div2C-ish | <details><summary>View</summary>Multi Dimensional problems can be reduced to single dimensions if they or the operations on them are independent.</details> | <details><summary>View</summary>recall the negative value shift</details> | [Solution](./codes/solution2.cpp) |
| 3 | [Link](https://atcoder.jp/contests/arc092/tasks/arc092_a) | adhoc | Div2C-ish | <details><summary>View</summary>In set<int, greater<int>>, the upper bound and lower bound functions act reverse. For example, lower bound returns the largest element less that or equal</details> | <details><summary>View</summary>recall the sorting based on x and left to right sweep with set maintainances</details> | [Solution](./codes/solution3.cpp) |
| 4 | [Link](https://cses.fi/problemset/task/2192/) | Geometry | Div2D-ish | <details><summary>View</summary>The Ray Casting algorithm is used for Point-in-Polygon. The key is the 'General Position' principle: use a slightly tilted ray (e.g., to a point like {x+1, large_y}) to avoid ambiguous edge cases like hitting a vertex or a perfectly vertical/horizontal edge.</details> | <details><summary>View</summary>Recall the two main bugs: 1) A vertical ray is fragile and fails on vertex cases. 2) Checking for collinear segment intersection requires an *overlap* check, not a *containment* check. Also, always use long long for cross products.</details> | [Solution](./codes/solution4.cpp) |
| 5 | [Link](https://codeforces.com/contest/621/problem/C) | Expected Value | Div2C |  |  | [Solution](./codes/solution5.cpp) |
| 6 | [Link](https://codeforces.com/contest/312/problem/B) | Probability | Div2B | <details><summary>View</summary>Recognizing the repeating states and finding the recurrence relation or the geometric series. The formula for the sum of an infinite geometric series A + A*R + A*R^2 +... is A / (1 - R). This formula is valid as long as the absolute value of R is less than 1. Since R is a product of probabilities, it will always be between 0 and 1, so we can use the formula.</details> |  | [Solution](./codes/solution6.cpp) |
| 7 | [Link](https://codeforces.com/contest/518/problem/D) | Probability and Expected Value | Div2D | <details><summary>View</summary>memset is a C-style function that works by setting each byte of a memory block to a specific value.<br><br>How memset Works: When you call memset(dp, -1, ...), it fills every single byte of the dp array with the byte pattern for -1, which is 0xFF in two's complement.<br><br>How long double is Stored: Floating-point numbers (like float, double, and long double) are not stored as simple integers. They are stored using a specific format (like IEEE 754), which has separate parts for the sign, the exponent, and the mantissa.<br><br>The Conflict: The byte pattern 0xFFFFFF... does not represent the number -1.0 in the floating-point standard. Instead, that specific bit pattern represents a NaN (Not a Number) value.</details> | <details><summary>View</summary>Use visited array when dp stores real numbers. Also look into the base case in this implementation.</details> | [Solution](./codes/solution7.cpp) |
| 8 | [Link](https://codeforces.com/contest/2149/problem/F) | Binary Search On Answer | Div3F |  | <details><summary>View</summary>Started coding without understanding statement clearly. It said each rest will increase health point by one and I missed this part and started writing a wrong solution.</details> | [Solution](./codes/solution8.cpp) |
| 9 | [Link](https://codeforces.com/contest/2149/problem/G) | Randomization, Segment Tree | Div3G | <details><summary>View</summary>Always analyze bounds of answer. In this problem, the upper bound of answer was at most two candidates in each range.</details> | <details><summary>View</summary>Recall why does randomization works in this problem and the math behind the probability. &lt;br&gt;Recall the calculation of the chance of failure.&lt;br&gt;Declaring a visited array inside each query costed TLE. Instead I could create candidates set for simplicity of the implementation.</details> | [Solution](./codes/solution9.cpp) |
<!-- PROBLEMS_TABLE_CONTENT -->

**Note:** Click on "View" in the Takeaway or Revisit Note columns to expand the content.
